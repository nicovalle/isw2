\section{Conclusiones}
\subsection{Metodologías utilizadas en la materia}
Tanto \textbf{Unified Process} como \textbf{Scrum} son metodologías para el desarrollo de software, que comparten la característica de seguir un modelo iterativo incremental, pero difieren en muchas otras cosas. Aún siguiendo modelos iterativos, por ejemplo, en \textbf{Scrum} cada iteración se planifica cuando termina la anterior, mientras que en \textbf{UP} se planifican todas al comienzo.

\textbf{Scrum} se vende como una metodología ágil con muy poca planificación, lo que la hace por lo tanto muy flexible y adaptable a los cambios y las diferentes circunstancias que vayan surgiendo a medida que se avanza en el desarrollo. Uno de sus pilares, \emph{individuos e interacciones sobre procesos y herramientas}, favorece la comunicación continua entre los programadores y el Project Owner (en forma de Stand Up Meetings), de manera de poder ir resolviendo rápidamente cualquier problema o inquietud que haya surgido. 

Otra máxima de la metodología \textbf{Scrum} es \emph{Software andando sobre documentación exhaustiva}, la cual pone en un lugar de privilegio al cliente, ya que éste valora más tener un software andando a documentación de desarrollo que nunca use y tal vez ni siquiera vea (hay que tener en cuenta, también, que muchas veces el cliente no sabe lo que quiere, por lo que empezar con el producto desde temprano permite que se definan mejor sus requerimientos). Es por esto también que a medida que se planea cada iteración de \textbf{Scrum} (donde están en juego todas las fases de una metodología de desarrollo clásica: requerimiento, análisis, diseño, desarrollo, testing, etc.), se privilegian las \emph{user stories} que le dan más \emph{business value} al cliente. Cada iteración de \textbf{Scrum} (inmodificable; las modificaciones que surjan deberán llevarse a cabo sí o sí en futuras iteraciones) concluye con la presentación de un \emph{entregable}, software ya andando y que debería poder ser puesto en producción, para poder obtener feedback

\textbf{Unified Process}, en cambio, sigue un proceso mucho más estricto guiado por la arquitectura y los casos de uso del software a desarrollar. Consta de 4 fases bien definidas (Inception, Elaboration, Construction y Transition), que se diferencian entre sí según la actividad en la que se haga hincapié (análisis del problema, desarrollo de la solución, etc., por poner dos ejemplos contrapuestos). Este enfoque más estructurado y con foco en la documentación (\emph{conocimiento}) permite ir desarrollando un modelo mental del software a construir e ir entrando en contacto con el problema y las maneras de solucionarlo.

A diferencia de \textbf{Scrum}, en \textbf{UP} el objetivo es en cada iteración ir evitando (o, de ser imposible, reduciendo) los riesgos del sistema a desarrollar, por lo que resulta clave tener un buen entendimiento del dominio del problema -e idealmente, experiencia en él- para ir previendo lo que pueda surgir. Si bien pueden haber entregables en cada etapa de \textbf{UP}, no necesariamente son \textit{código ejecutable}: pueden ser documentos de requerimiento, de análisis de dominio, u otros.

Al tener mucha planificación de entrada, resulta más fácil en \textbf{UP} tener una idea estimada de cuándo finalizará el proyecto, algo que no sucede en \textbf{Scrum} (siempre y cuando, claro, que en UP se hayan estimado bien las cosas, algo que no siempre sucede).

Por lo descrito, \textbf{Scrum} se presenta como una solución ventajosa para proyectos poco críticos y de poca duración, con equipos chicos y sin fechas de finalización estrictas, donde la adaptabilidad y flexibilidad sean importantes para la concreción del desarrollo. Por el enfoque más formal, \textbf{UP} se presenta como una solución ideal para proyectos grandes, complejos, con equipos numerosos, y donde las fechas sean estrictas y jueguen un rol importante.

\newpage
\subsection{Programming in the large \textit{vs} Programming in the small}

