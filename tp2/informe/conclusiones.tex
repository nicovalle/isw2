\section{Conclusiones}
\subsection{Metodologías utilizadas en la materia}
Tanto \textbf{Unified Process} como \textbf{Scrum} son metodologías para el desarrollo de software, que comparten la característica de seguir un modelo iterativo incremental, pero difieren en muchas otras cosas. Aún siguiendo modelos iterativos, por ejemplo, en \textbf{Scrum} cada iteración se planifica cuando termina la anterior, mientras que en \textbf{UP} se planifican todas al comienzo.

\textbf{Scrum} se vende como una metodología ágil con muy poca planificación, lo que la hace por lo tanto muy flexible y adaptable a los cambios y las diferentes circunstancias que vayan surgiendo a medida que se avanza en el desarrollo. Uno de sus pilares, \emph{individuos e interacciones sobre procesos y herramientas}, favorece la comunicación continua entre los programadores y el Project Owner (en forma de Stand Up Meetings), de manera de poder ir resolviendo rápidamente cualquier problema o inquietud que haya surgido. 

Otra máxima de la metodología \textbf{Scrum} es \emph{Software andando sobre documentación exhaustiva}, la cual pone en un lugar de privilegio al cliente, ya que éste valora más tener un software andando a documentación de desarrollo que nunca use y tal vez ni siquiera vea (hay que tener en cuenta, también, que muchas veces el cliente no sabe lo que quiere, por lo que empezar con el producto desde temprano permite que se definan mejor sus requerimientos). Es por esto también que a medida que se planea cada iteración de \textbf{Scrum} (donde están en juego todas las fases de una metodología de desarrollo clásica: requerimiento, análisis, diseño, desarrollo, testing, etc.), se privilegian las \emph{user stories} que le dan más \emph{business value} al cliente. Cada iteración de \textbf{Scrum} (inmodificable; las modificaciones que surjan deberán llevarse a cabo sí o sí en futuras iteraciones) concluye con la presentación de un \emph{entregable}, software ya andando y que debería poder ser puesto en producción, para poder obtener feedback

\textbf{Unified Process}, en cambio, sigue un proceso mucho más estricto guiado por la arquitectura y los casos de uso del software a desarrollar. Consta de 4 fases bien definidas (Inception, Elaboration, Construction y Transition), que se diferencian entre sí según la actividad en la que se haga hincapié (análisis del problema, desarrollo de la solución, etc., por poner dos ejemplos contrapuestos). Este enfoque más estructurado y con foco en la documentación (\emph{conocimiento}) permite ir desarrollando un modelo mental del software a construir e ir entrando en contacto con el problema y las maneras de solucionarlo.

A diferencia de \textbf{Scrum}, en \textbf{UP} el objetivo es en cada iteración ir evitando (o, de ser imposible, reduciendo) los riesgos del sistema a desarrollar, por lo que resulta clave tener un buen entendimiento del dominio del problema -e idealmente, experiencia en él- para ir previendo lo que pueda surgir. Si bien pueden haber entregables en cada etapa de \textbf{UP}, no necesariamente son \textit{código ejecutable}: pueden ser documentos de requerimiento, de análisis de dominio, u otros.

Al tener mucha planificación de entrada, resulta más fácil en \textbf{UP} tener una idea estimada de cuándo finalizará el proyecto, algo que no sucede en \textbf{Scrum} (siempre y cuando, claro, que en UP se hayan estimado bien las cosas, algo que no siempre sucede).

Por lo descrito, \textbf{Scrum} se presenta como una solución ventajosa para proyectos poco críticos y de poca duración, con equipos chicos y sin fechas de finalización estrictas, donde la adaptabilidad y flexibilidad sean importantes para la concreción del desarrollo. Por el enfoque más formal, \textbf{UP} se presenta como una solución ideal para proyectos grandes, complejos, con equipos numerosos, y donde las fechas sean estrictas y jueguen un rol importante.

\newpage
\subsection{Programming in the large \textit{vs} Programming in the small}
La diferencia entre \textbf{programming in the large} y \textbf{programming in the small} parecería desprenderse de la distinción sobre en qué tipo de proyecto es más apto utilizar Scrum o UP. 

\textbf{Programming in the large} consiste en el desarrollo de proyectos de software de gran tamaño, donde están inmersos muchos participantes con requerimientos y necesidades a veces contrapuestos, y durante un período largo de tiempo. Por esa razón conviene un acercamiento estructurado al problema, como el que propone UP, donde conocer los \emph{drivers} del proyecto, las prioridades, los atributos de calidad, tener cronogramas definidos, etc. se vuelve de gran importancia. Descomponer el problema en subsistemas permite que estos puedan ser desarrollados por distintos equipos. 

La arquitectura juega un rol vital en el caso de \textbf{programming in the large}, puesto que permite tener una primera definición de la solución, ver las estructuras del sistema, sus relaciones y propiedades de sus elementos, evitando potenciales problemas posteriores que requieran un cambio mayor en el diseño del sistema y que redunde en un costo muy alto.

\texbtf{Programming in the small} podría ser considerado como el desarrollo de cada uno de los submódulos que componen un sistema mayor. Al estar mucho más circunscripto el alcance de un único módulo, un error puede no ser tan costoso de corregir, por lo que se relajan las tareas de planificación, de análisis de riesgo, y de documentación (pues el sistema es más pequeño y, por lo tanto, más simple de comprender).

\newpage
\subsection{Conclusiones del grupo}
La diferencia conceptual entre los dos TPs de la materia es clara, y esa experiencia es algo que (sentimos que) permea lo que fuimos escribiendo en las últimas dos subsecciones. El primer TP tuvo un enfoque de programming in the small, desarrollando un sistema a pequeña escala y con una metodología bastante particular (justamente por la libertad que ofrece); el segundo TP tuvo un enfoque mucho más estructurado y minucioso, donde no tener un detalle en cuenta al principio ocasionaba una verdadera bola de nieve más adelante (no darle importancia a alguna frase en particular del enunciado puede llevar a cosas importantes y ausentes en la arquitectura final del sistema), por lo que había que ser extremadamente cuidadoso.

Con respecto a UP en sí, más allá de la estructura (en cuanto a cronogramas) y la metodología en sí (las iteraciones, las fases), nos resultaron más interesantes las herramientas utilizadas. Es interesante aprender nuevas herramientas para poder expresar lo que se necesita/espera de un sistema por desarrollar (con los casos de uso, los atributos de calidad, los escenarios como método de desambiguación de los mismos, la arquitectura y todo su lenguaje asociado como primer acercamiento a una solución, etc.), esta expansión de nuestro lenguaje profesional es interesante y nos permitirá en un futuro utilizar las cosas que consideremos útiles del mismo para la realización de nuevos proyectos. Conocer también el estándar de las tácticas es algo importante, para no reinventar la rueda constantemente.

En ninguno de los dos TPs podemos decir que aplicamos la metodología respectiva al 100\%, y ni siquiera un porcentaje algo menor. Seguimos considerando que el tiempo, el ámbito y las circunstancias no son las apropiadas como para poder entrar en calor con ellas y poder ejercer una fuerte opinión sobre sus ventajas y sus desventajas.

