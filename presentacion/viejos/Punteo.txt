Werewolves - Software: They're both something familiar that turns itself into a monster.


The essence of a software entity is a construct of interlocking concepts. This essence is abstract in that such a conceptual construct is the same under many different representations. It is nonetheless highly precise and richly detailed. "I believe the hard part of building software to be the specification, design and testing of thise conceptual construct. No the labor of representing it and testing the fidelity of the representation".


Essential problems:
- Complexity: no to parts are alike. There is a very large number of states. From the complexity comes the difficulty of communication among team members
- Conformity: much of the complexity that he must master is arbitrary complexity, forced without reason by the human institutions and systems to which the system must conform.
- Changeability: it is pure thought-stuff, infinitely malleable.
- Invisibility: as soon as we attempt to diagram software structure, we find it to constitute not one, but several, general directed fraphs superimposed one upon another. Each graph may represent different aspects. This has problems communication among peers as well as desinging in only one mind.


Breakthroughts that solved accidental problems:
- High-level languajes: it eliminates a whole level of complexity that was never inherent in the program at all. It was in the machine (or it's interaction with software), but not in the abstraction that is the program.
- Time-sharing: the princial effecft is to shorten system response time. As this response passes the human threshold of noticeability, it won't improve anything.
- Unified programming enviroments:


Hopes for the silver:
- high-level languaje advances: no. same reason as before.
- object-oriented programming:
- - abstract data type: an object's type should be defined by a name, a set of proper values and a set of proper operations, rather than by its storage structure, which shoud be hidden.
- - Hierarchical types: allow one to define general interfaces.
        Both of these remove an accidental difficulty, not essential.
- Artificial intelligence.
- Expert systems.
- Program verification: so much work. Besides, even perfect program verification can establish that a program meets is specification. THe hardest part of the software is arriving at a complete and consistent specification.


Attacks that have a chance:
- Buy vs Build.
- Requirements refinement and rapid prototyping: the hardest and most delicate part is deciding what to build. A prototype software system is one that simulates the important interfaces and performs the main functions of the intendedn system (without limitations of computing, cost, etc.). Making this prototype helps a lot in deciding what to build. The problem is that those limitations may later prove to be deal-breakers.
- Growing vs building. Brain analogy.
- Great designers.

